---
title: "R Example Document"
author: "Daniel R. Kick"
date: 'Last updated: `r Sys.Date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Loading and installing libaries
Part of R's power is that we can use functions that other people have made to manipulate data, run statistical tests, and make graphs.
To install a library (in this example `tidyverse`) use the below command. The `#` character defines a comment. This means that everything on the same line after it is not evaluated. Comments allow us to show optional code without running it, provide notes to other users, or temporarily remove code as you write and improve your scirpts.
```{r}
# <- This is makes a comment

#Note that the library name must be in quotes
#install.packages("tidyverse") 
```

If you have already installed a package, you can load it with the `library()` command.
```{r}
#Note that the library name does not need to be in quotes here
library(tidyverse) #tidyverse loads a bunch of useful packages by the talented Hadley Wickham
#The packages we'll use most are for manipulating data (tidyr, dplyr) and visualizing data (ggplot2)
library(ggthemes) #This extends ggplot2 with several formatting options
library(ggsci) #This lets us select color schemes to use in lieu of the default
library(cowplot) #This also extends ggplot2

library(readxl) #This lets us read data from excel documents (.xlsx)

library(AICcmodavg) #This lets us easily compare how good different model are

library(agricolae) #This has a post hoc test we'll want to use: `HSD.test`
library(car) #This makes nice anova tables
```

##Getting data in and out of R

R has a few datasets availible for use. For these examples, were using the `iris` dataset. You can see all the datasets availible with the command `data()`. We can take a look at the top few rows with the `head()` function. If you want to know more about the `iris` dataset type `?iris` into the console and hit return.

```{r}
head(iris)
```

Lets say we didn't have access to `iris` natively. We would have to import it from a spreadsheet. The two most common formats for these files to be in are `csv` (comma separated values) and `xlsx` (Excel). 
To get data into R we need to know:
 - What the data's format is
 - Where it lives on your computer
 
In my case, `iris` is saved in two versions (csv and excel) on a hard drive in a sub folder called `data`. To work with the data, I need to tell R the filepath so it knows where to look for the data and what I want it to be assigned to.
```{r}
#Here I've used the function "read.csv" to get the data into R and assigned it to the name "iris_csv"
#We use the `<-` opperator to assign one thing to another. We can read the line below as "iris_csv gets the data in the file at this location."
iris_csv <- read.csv(file = "~/Box Sync/Bio 3700 TA material/00_Reference_R_Scripts/data/iris.csv")

""

#Here I've told R to read in the excel formated data. 
#Once again we've assigned it to a memorable name. 
#Note that this function uses an argument called "path" instead of "file" like read.csv does
iris_xlsx <- read_xlsx(path = "~/Box Sync/Bio 3700 TA material/00_Reference_R_Scripts/data/iris.xlsx")
```

With the data read in we want to take a look at it. There are a few commands we can use to accomplish this. `head()` or `tail()` will show us the first or last few rows respectively. We would like to know about the *structure* of the data as well. We can use the `str()` (structure) command to get a look at the data and how it's represented within R. We can also use `tidyverse`'s `glimpse` funciton which shows us the data but unlike `str()` it doesn't tell us about the way (class) that R stores the data under the hood.
```{r}
glimpse(iris_csv)
```

```{r}
str(iris_csv)
```

Now we'll do the same for `iris_xlsx`.
```{r}
str(iris_xlsx)
```

Notice how the output is slightly different? We have the same data but it's represented differently. For one thing, the column `Species` in `iris_csv` is fillied with factors where as `iris_xlsx` has characters (chr). You'll also notice that `iris_csv` is something called a `data.frame` wheras `iris_xlsx` is something called a `tbl_df` (a tibble dataframe or tibble). You can think of these as two slightly different types of spread sheets. What's important to remember is that tibbles and dataframes work *almost but not entirely* the same way. So you don't have to worry about the differences we'll convert both into `data.frame` format.
```{r}
iris_csv <- as.data.frame(iris_csv)
iris_xlsx <- as.data.frame(iris_xlsx)
```

We can confirm this worked by asking for the `class` of an object.
```{r}
class(iris_xlsx)
```

Let's suppose that after making some modifications to our data we want to save it so other programs can access it. We accomplish this with the `write.csv()` funciton. 
```{r}
write.csv(iris_xlsx, "~/Box Sync/Bio 3700 TA material/00_Reference_R_Scripts/data/iris_processed.csv", row.names = FALSE) #if row.names equals TRUE you'll end up with a column that has the row number in it.
```

## Basic Visualization

There are a lot of ways to visualize data in R, but for the sake of this class we'll stick to a common library called `ggplot2`.

Let's take a closer look at that iris data set. 
```{r}
head(iris)
```

 Let's make a scatterplot to see if there is a relationship between sepal length and sepal width.
```{r}
ggplot(iris, #The first argument is the data.frame we're using
       aes(x = Sepal.Length, #within the aes funciton we specify what data we want on the x and y
           y = Sepal.Width,
           color = Species))+ #Color points by Species
  geom_point()+ #this function tells ggplot that we want a scatterplot
  theme_tufte()+ #This lets us select formatting options that other people have put together. This is from the ggthemes package.
  scale_color_aaas() #This lets us choose the color palate used in AAAS journals. This is from the ggsci package.
```

We can see that we have four measurements for several species of iris. Let's say we want to figure out what makes these three species different. We can look at each of these columns seperately to see which are best at distinguishing between the three species.
```{r}
ggplot(iris, aes(x = Species, y = Sepal.Length))+
  geom_boxplot()
```

Above, we used three functions. First we called `ggplot` and specified the data. Within ggplot we called the function `aes` which stands for aesthetics. This function let's us tell R what we want to be on each axis and if we want shapes to colored by a variable. Finally, we called `geom_boxplot`. `ggplot` has many plots availble that follow the format of geom_"some plot name". If you're trying to find something specific and don't know what geom to use, you should be able to find help pages and examples online with ease; it's a popular libary.

Let's spice up our plot by adding a title, editing the axis labels, using color and showing the data itself. To show how we can iteratively improve out plots, we'll assign each of these to a variable and plot them together. We can show multiple plots at once by using `cowplot`'s `plot_grid` funciton.
```{r}
plot1 <- ggplot(iris, aes(x = Species, y = Sepal.Length))+
  geom_boxplot()

plot2 <- ggplot(iris, aes(x = Species, y = Sepal.Length))+
  geom_boxplot()+
  labs(title = "Add Title") #This is added

plot3 <- ggplot(iris, aes(x = Species, y = Sepal.Length))+
  geom_boxplot()+
  labs(title = "Add Labels", x = "Species Sampled", y = "Sepal Length (cm)") #This is changed

plot4 <- ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species))+ #This is changed
  geom_boxplot()+
  labs(title = "Color Boxplots", x = "Species Sampled", y = "Sepal Length (cm)")

plot5 <- ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species))+
  geom_boxplot()+
  labs(title = "Change Legend Position", x = "Species Sampled", y = "Sepal Length (cm)")+
  theme(legend.position = "bottom") #This is added

plot6 <- ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species))+
  geom_boxplot()+
  labs(title = "Change Color Palate", x = "Species Sampled", y = "Sepal Length (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()

plot_grid(plotlist = list(plot1,
                          plot2,
                          plot3,
                          plot4,
                          plot5,
                          plot6))
```

By the end we have a pretty handsome plot. Let's make plots for each column to figure out what best separates the three species



To do make our job easier, we can look at each variable at once. We'll make four box plots, save them, and pass them into a cowplot's `plot_grid` function to look at them all at  once.
```{r}
p1 <- ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species))+
  geom_boxplot()+
  labs(title = "", x = "Species Sampled", y = "Sepal Length (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()

p2 <- ggplot(iris, aes(x = Species, y = Sepal.Width, fill = Species))+
  geom_boxplot()+
  labs(title = "", x = "Species Sampled", y = "Sepal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()

p3 <- ggplot(iris, aes(x = Species, y = Petal.Length, fill = Species))+
  geom_boxplot()+
  labs(title = "", x = "Species Sampled", y = "Petal Length (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()

p4 <- ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species))+
  geom_boxplot()+
  labs(title = "", x = "Species Sampled", y = "Petal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()

plot_grid(plotlist = list(p1,
                          p2,
                          p3,
                          p4))
```

Looks like the least overlap is in the length and width of the petals. Let's make a scatterplot with `geom_point` of the petal width and length.
```{r}
ggplot(iris, aes(x = Petal.Length, y = Petal.Width, fill = Species))+
  geom_point()+
  labs(title = "Petal Length vs Width", x = "Petal Length (cm)", y = "Petal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()
```

Even thought we didn't change `fill = Species` in `aes()` we don't have colored points. We can imagine these fill as coloring two dimensional shapes, but out points are just that. We have to use `color = Species` to fix this.
```{r}
ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species))+
  geom_point()+
  labs(title = "Petal Length vs Width", x = "Petal Length (cm)", y = "Petal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()
```

Much better. It looks like there's a species difference, but also a relationship between petal length and petal width. What kind of model would best describe the data?
A model that predicts...
  - Petal Width by Petal Length?
  - Petal Width by Species?
  - Petal Width by Petal Length AND Species?

## Model Generation

To find out what model best describes the data we'll make each of these models and compare them with AICc.

### Petal Width by Petal Length (Regression)

We can make an ordinary least squared regression model with the `lm()` function.
```{r}
reg.model <- lm(Petal.Width ~ Petal.Length, iris)
```

Next we'll visualize our model by predicting the petal width by it's length.
```{r}
iris <- mutate(iris, reg = predict(reg.model)) #This adds column "reg" to iris

ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species))+
  geom_point()+
  geom_line(aes(x = Petal.Length, y = reg, group = 1), lwd = 1 )+ #This line is new
  labs(title = "Petal Length vs Width", x = "Petal Length (cm)", y = "Petal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()
```


### Petal Width by Species (ANOVA)

Next we'll make a model based on species. 
```{r}
ano.model <- lm(Petal.Width ~ Species, iris)
```

```{r}
iris <- mutate(iris, ano = predict(ano.model)) #This adds column "ano" to iris

ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species))+
  geom_point()+
  geom_line(aes(x = Petal.Length, y = ano), lwd = 1 )+ #This line is changed
  labs(title = "Petal Length vs Width", x = "Petal Length (cm)", y = "Petal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()
```

### Petal Widht by Petal Length and Species (ANCOVA)

```{r}
anc.model <- lm(Petal.Width ~ Species + Petal.Length, iris)
```

```{r}
iris <- mutate(iris, anc = predict(anc.model)) #This adds column "ano" to iris

ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species))+
  geom_point()+
  geom_line(aes(x = Petal.Length, y = anc), lwd = 1 )+ #This line is changed
  labs(title = "Petal Length vs Width", x = "Petal Length (cm)", y = "Petal Width (cm)")+
  theme(legend.position = "bottom")+
  ggsci::scale_fill_aaas()
```

## Compare the models we've made:

```{r}
AICcmodavg::aictab(cand.set = list(Regression = reg.model, 
                                   ANOVA = ano.model, 
                                   ANCOVA = anc.model))
```

```{r}
reg.model %>% summary()
```

### Understanding the ANOVA

Let's take a look at our ANOVA model. 
First we can take a look at this model with `summary()`
```{r}
summary(ano.model)
```

We can use `Anova()` from the `car` library to make nicely formatted ANOVA table. Note that this is a different function than the `anova()` function. Here `type = "III"` refers to the sums of squares. This will show if there is a "main effect". This will tell us if it makes sense for us to run a post hoc test.
```{r}
Anova(ano.model, type = "III")
```

To run a post hoc test on this model (if there is a main effect) we're using the `agricolae` package's function `HSD.test()` to run Tukey's Honest Significant Difference as a post hoc test. This test shows us what groups exist. If there was a single one (there's no difference) all the letters would be the same. In this case each species is its own group.
```{r}
comparison <- HSD.test(ano.model, "Species", group=TRUE)
comparison$groups #The "$" means that we're selecting "groups" from the variable "comparison"
```



Finally, let's do post hoc tests on these models
```{r}
```



```{r}
anc.model

```

